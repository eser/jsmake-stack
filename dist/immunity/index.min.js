function r(r,...e){return[...r,...e]}const e=Object.hasOwnProperty("assign")?Object.assign:function(r,...e){return e.forEach(e=>{null!=e&&Object.getOwnPropertyNames(e).forEach(t=>{r[t]=e[t]})}),r};function t(r,...t){return e({},r,...t)}function n(r){const t=r.constructor;return Object.keys(r).reduce((c,o)=>!(r[o]instanceof Function)&&r[o]instanceof Object?e(new t,c,{[o]:n(r[o])}):e(new t,c,{[o]:r[o]}),new t)}function c(r,e){return(r.constructor===Array?r:[...r]).slice(e)}function o(r,t){const n=Object.keys(r);let c=0;return n.reduce((n,o)=>t>c?(c+=1,n):e({},n,{[o]:r[o]}),{})}function u(r,e){return(r.constructor===Array?r:[...r]).filter(e)}function s(r,t){return Object.keys(r).reduce((n,c)=>t(r[c],c,n)?e({},n,{[c]:r[c]}):n,{})}function i(r,e){return(r.constructor===Array?r:[...r]).map(e)}function f(r,t){return Object.keys(r).reduce((n,c)=>{const o=t(r[c],c,n);return null!==o?e({},n,o):n},{})}function a(...r){return r.reduce((r,e)=>[...r,...e],[])}function m(...r){return e({},...r)}function y(r,e){const t=r.constructor===Array?r:[...r],n=e.constructor===Array?e:[...e];return t.reduce((r,e)=>-1!==n.indexOf(e)?{items:[...r.items,e],rest:r.rest}:{items:r.items,rest:[...r.rest,e]},{items:[],rest:[]})}function O(r,t){return Object.keys(r).reduce((n,c)=>-1!==t.indexOf(c)?{items:e({},n.items,{[c]:r[c]}),rest:n.rest}:{items:n.items,rest:e({},n.rest,{[c]:r[c]})},{items:{},rest:{}})}function b(r,...e){return[...e,...r]}function j(r,...t){return e({},...t,r)}function d(r,e){const t=r.constructor===Array?r:[...r];let n=!0;return t.filter((r,t,c)=>!n||!e(r,t,c)||(n=!1,!1))}function l(r,t){let n=!0;return Object.keys(r).reduce((c,o)=>n&&t(r[o],o,c)?(n=!1,c):e({},c,{[o]:r[o]}),{})}function p(r,...e){return(r.constructor===Array?r:[...r]).filter(r=>-1===e.indexOf(r))}function A(r,...t){return Object.keys(r).reduce((n,c)=>-1===t.indexOf(c)?e({},n,{[c]:r[c]}):n,{})}function k(r,...t){return Object.keys(r).reduce((n,c)=>-1===t.indexOf(r[c])?e({},n,{[c]:r[c]}):n,{})}function F(r){return(r.constructor===Array?r:[...r]).reduce((r,e)=>[e,...r],[])}function v(r){return Object.keys(r).reduce((t,n)=>e({},{[n]:r[n]},t),{})}function x(r,e){const t=r.constructor===Array?r:[...r];return{items:t.slice(0,e),rest:t.slice(e)}}function g(r,t){const n=Object.keys(r);let c=0;return n.reduce((n,o)=>c<t?(c+=1,{items:e({},n.items,{[o]:r[o]}),rest:n.rest}):{items:n.items,rest:e({},n.rest,{[o]:r[o]})},{items:{},rest:{}})}function h(r,e){return(r.constructor===Array?r:[...r]).slice(0,e)}function w(r,t){let n=0;return Object.keys(r).reduce((c,o)=>n<t?(n+=1,e({},c,{[o]:r[o]})):c,{})}const T={appendToArray:r,appendToObject:t,copy:n,dropFromArray:c,dropFromObject:o,filterArray:u,filterObject:s,mapArray:i,mapObject:f,mergeArrays:a,mergeObjects:m,pickFromArray:y,pickFromObject:O,prependToArray:b,prependToObject:j,removeFirstMatchFromArray:d,removeFirstMatchFromObject:l,removeFromArray:p,removeKeyFromObject:A,removeValueFromObject:k,reverseArray:F,reverseObject:v,splitArray:x,splitObject:g,takeFromArray:h,takeFromObject:w};export default T;export{r as appendToArray,t as appendToObject,n as copy,c as dropFromArray,o as dropFromObject,u as filterArray,s as filterObject,i as mapArray,f as mapObject,a as mergeArrays,m as mergeObjects,y as pickFromArray,O as pickFromObject,b as prependToArray,j as prependToObject,d as removeFirstMatchFromArray,l as removeFirstMatchFromObject,p as removeFromArray,A as removeKeyFromObject,k as removeValueFromObject,F as reverseArray,v as reverseObject,x as splitArray,g as splitObject,h as takeFromArray,w as takeFromObject};
