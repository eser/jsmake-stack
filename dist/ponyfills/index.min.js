function e(e,r,t){const n=null==t?this:t;if(null==e)throw new TypeError("Array.from requires an array-like object - not null or undefined");if(null!=r){if(!(r instanceof Function))throw new TypeError("Array.from: when provided, the second argument must be a function");return[...e].reduce((e,t,o)=>[...e,r.call(n,t,o)],[])}return[...e]}const r=Array.hasOwnProperty("from")?Array.from:e;function t(e,...r){return r.forEach(r=>{null!=r&&Object.getOwnPropertyNames(r).forEach(t=>{e[t]=r[t]})}),e}const n=Object.hasOwnProperty("assign")?Object.assign:t;function o(e){return[...Object.getOwnPropertyNames(e),...Object.getOwnPropertySymbols(e)]}const c=Reflect.hasOwnProperty("ownKeys")?Reflect.ownKeys:o;function s(e){return c(e).reduce((r,t)=>t.constructor===String&&e.propertyIsEnumerable(t)?[...r,[t,e[t]]]:r,[])}const l=Object.hasOwnProperty("entries")?Object.entries:s;function u(e){return c(e).reduce((r,t)=>t.constructor===String&&e.propertyIsEnumerable(t)?[...r,e[t]]:r,[])}const a=Object.hasOwnProperty("values")?Object.values:u,i={arrayFrom:r,arrayFromPolyfill:e,objectAssign:n,objectAssignPolyfill:t,objectEntries:l,objectEntriesPolyfill:s,objectValues:a,objectValuesPolyfill:u,reflectOwnKeys:c,reflectOwnKeysPolyfill:o};export default i;export{r as arrayFrom,e as arrayFromPolyfill,n as objectAssign,t as objectAssignPolyfill,l as objectEntries,s as objectEntriesPolyfill,a as objectValues,u as objectValuesPolyfill,c as reflectOwnKeys,o as reflectOwnKeysPolyfill};
